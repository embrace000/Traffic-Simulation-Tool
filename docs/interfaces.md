系统将定时访问数据库中特定表项来决定工作内容，假定该表为work。work表中有配置名称、工作类型、配置内容、该配置的状态以及失败原因（如果配置未能成功应用）。当系统访问work表的内容时，配置状态为“尚未应用”的行，然后根据其类型和内容构建流量生成工作，最后根据构建结果更新work表中该配置的状态。配置名称为字符串，工作类型分为“流量重放”、“流量生成”、“流量记录”和“流量比较”四种，配置内容即为json格式的内容，配置的状态分为“应用成功”、“应用失败”、“应用结束”以及“尚未应用”。配置名称、工作类型、配置内容是根据用户输入设置的，而配置状态和失败原因则由系统设置。

流量重放json文件内容格式如下：

```json
{
	"Characteristic": "重放类型"，
	“Total”：数据包总量，
	“Nodes”：{
		“节点名称”：{
			“IP”：“IP地址”，
			“MAC”：“MAC地址”
}，
……
}，
“Requirements”：{
	“节点名称1->节点名称2:id”：{
		“Type”：“流量类型”，
		“Delay”：延迟开始时间，
		“Duration”：持续时间，
		“Weight”：该流量的权重，
		“Rate”：发包速率，
}，
……
}，
“TrafficFile”：{
	“流量类型”：“pcap文件路径”，
	……
}
}
```

重放类型分为“Proportion”和“Simulation”即按照比例重放和直接重放。按照比例重放单独需要“数据包总量信息”（整型）、“流量的权重”（浮点型）和“发包速率”（整型，即每秒发多少数据包），这些信息在直接重放中不需要。直接重放则单独需要“持续时间”（浮点型）。不同的流量使用“A->B:1”来表示从节点A到节点B的id为1的流量。由于是根据“流量类型”寻找对应的pcap文件，所以可以使用ftp1、“ftp2”这种方式来指定不同的pcap文件。

流量生成json文件内容格式如下：

```json
{
	“Servers”：{
		“节点名称”：{
			“Image_tag”：“容器镜像名称:标签”，
			“Name”：“启动的容器的名称”，
			“Environment”：{
				“容器中环境变量的键n”：“对应的值”，
				……
}，
“Command”：“容器启动之后立即执行的命令”，
“Volume”：[
	“要挂载到容器中的宿主机中文件夹的路径”：“在容器中的挂载点路径”，
	……
]，
“Network”：“网络模式”
}
}，
“Clients”：{
	……
}
}
```

客户端节点和服务器节点的格式相同，均为“节点名称：{各种节点配置}”的形式，这些配置本质上就是“docker run”所需的参数。容器可以由用户设置ip和mac，但是此时应当由用户自行保证ip和mac不和现有的冲突。“Image_tag”为容器镜像的名称和标签，例如“httpd:latest”代表提供httpd服务的镜像的最新版本，应当和本地保存的镜像一致。“Environment”包含的“键：值”对会在容器启动后设置为容器中进程可访问的环境变量。“Command”则为容器启动之后立即执行的命令，例如“python /usr/src/main.py”。容器中运行的程序可能需要一些特殊的文件，此时可利用“Volume”将这些文件所在的文件夹挂载到容器中，例如容器启动之后需要用python执行一些python文件，那么这些python文件所在的文件夹可以挂载到容器中。“Network”即容器的网络模式，但是由于代码实现目前推荐仅设置为“bridge”，表示这些容器由docker自动分配ip和mac。

流量记录json文件内容格式如下：

```json
{
	“Proto”：{
		“流量类型n”：{
			“Ports”：[端口号1，端口号2，……]
}，
……
},
	“Time”：记录持续时间，
	“Interval”：记录数据的间隔时间，
	“Interfaces”：[“网络接口1”，“网络接口2”，……]
}
```

由于是根据端口区分不同流量的，所以本质上是给不同的端口的流量指定一个标签，会根据这些端口捕获流量，并结合对应的标签输出文本。“Interval”代表多长时间更新一次捕获的数据包信息，可以当做多长时间刷新并输出一次捕获信息。容器流量一般需要在特殊接口捕获，例如“docker0”，和本机常用网络接口不同，所以需要使用“Interfaces”来指定捕获流量的接口。